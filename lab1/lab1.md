# lab1实验报告
小组成员：何阳、李国祎、石长伟
## lab0.5部分
## 实验内容：
>熟悉使用 qemu 和 gdb 进行调试工作, 使用 gdb 调试 QEMU 模拟的 RISC-V 计算机加电开始运行到执行应用程序的第一条指令（即跳转到 0x80200000）这个阶段的执行过程，说明 RISC-V 硬件加电后的几条指令在哪里？完成了哪些功能？
## 实验过程：

  1. 使用 make debug 命令启动 QEMU 模拟器，并加载要调试的镜像文件，在另一个终端中，使用 make gdb 命令连接到 QEMU 模拟器并启动 gdb 调试器：
![1.png](https://s2.loli.net/2023/09/22/SBVb7WUnp9veYzf.png)

2.查看当前的指令
![2.1.png](https://s2.loli.net/2023/09/23/nLUZvt86uRjwd3s.png)

3.说明 RISC-V 硬件加电后的几条指令在哪里？
答：我们知道了复位地址0x1000，我们查看该地址的指令
![3.2.png](https://s2.loli.net/2023/09/23/Oo4cDR1WYv76BKX.png)

4.说明 RISC-V 硬件加电后的几条指令完成了哪些功能？？
答：
0x1000: auipc t0, 0x0：将当前 PC 寄存器的高 20 位与立即数 0x0 相加，并将结果存储在寄存器 t0 中。

0x1004: addi a2, t0, 40：将寄存器 t0 的值与立即数 40 相加，并将结果存储在寄存器 a2 中。

0x1008: csrr a0, mhartid：将处理器的硬件线程 ID 存储在寄存器 a0 中。

0x100c: ld a1, 32(t0)：从寄存器 t0 加上偏移量 32 的地址处加载一个双字，并将结果存储在寄存器 a1 中。

0x1010: ld t0, 24(t0)：从寄存器 t0 加上偏移量 24 的地址处加载一个双字，并将结果存储在寄存器 t0 中。

0x1014: jr t0：跳转到寄存器 t0 中存储的地址处执行指令。

0x1018: unimp：未实现的指令。

0x101a: 0x8000：立即数 0x8000。

0x101c: unimp：未实现的指令。

0x101e: unimp：未实现的指令。
## lab1部分
## 练习1：理解内核启动中的程序入口操作
>阅读 kern/init/entry.S内容代码，结合操作系统内核启动流程，说明指令 la sp, bootstacktop 完成了什么操作，目的是什么？ tail kern_init 完成了什么操作，目的是什么？

操作系统启动流程为：
1. 加电后，计算机读取OpenSBI的程序
2. 计算机通过OpenSBI，检查硬件并加载启动加载程序到内存中
3. 启动加载程序会加载操作系统内核到内存中的某个特定位置，然后跳转到内核的入口点开始执行。

la sp, bootstacktop：这行代码使用伪指令la将栈指针寄存器sp设置为bootstacktop的地址，初始化栈并分配空间，为内核执行分配一个有效不冲突的栈。

tail kern_init：将程序的控制流转移到kern_init函数，通过kern_init函数开始执行内核的初始化过程。


## 练习2：完善中断处理 

>请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写kern/trap/trap.c函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的shut_down()函数关机

- 实现代码如下：
~~~
case IRQ_S_TIMER:
    clock_set_next_event();
    ticks++;
    if(ticks%TICK_NUM==0){
        print_ticks();
        num++;
    }
    if(num==10){
        sbi_shutdown();
    }
    break;
~~~

- 实现过程
发生时钟中断时，进入对应的case，首先调用clock_set_next_event()函数，去设置10ms后触发下次时钟中断。然后将中断次数ticks加1，当ticks模取100为0时，说明此时已经触发了100次的时钟中断(时间已经过了1秒钟)。此时输出一行信息到控制台，并记录输出的次数。当输出十行信息时，调用shi.h中的shut_down()函数关机。
- 定时器中断处理流程
“时钟中断”实际上就是一个“每隔若干个时钟周期执行一次的程序”。为了保证一个程序不会永远运行下去，我们需要设置这样的一个定时打断功能，让当前程序让出CPU去执行检查的程序。一般而言，我们选择时钟中断间隔为CPU频率的1%，即10ms触发一次中断。但是，OpenSBI提供的接口一次只能设置一个时钟中断，所以在实现代码时，采用一开始只设置一个时钟中断，之后每次发生时钟中断时再设置下一次的时钟中断。
所以定时器的中断处理流程是这样的：set_sbi_timer()通过OpenSBI的时钟时间触发一个中断，跳转到kern/trap/trapentry.S的__alltraps标记，保存当前上下文，切换为kern/trap/trap.c的中断处理函数trap()的上下文，切换前的上下文作为它的函数参数；然后根据中断类型判断去执行时钟中断的处理语句，并设置好了下一次的时钟中断；完成处理后返回kern/trap/trapentry.S恢复原先上下文，中断处理结束。

执行make qemu，可看到打印十行100 ticks后正常关机。
![l1-e2.png](https://s2.loli.net/2023/09/22/13vFzbgaNhJ4RPn.png)



## 扩展练习 Challenge1：描述与理解中断流程
>描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？SAVE_ALL中寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由

1.ucore中处理中断异常的流程
* 异常的产生：当系统执行时出现异常或中断时，硬件将会产生相应的异常或中断信号。
* 硬件处理：当异常或中断信号产生后，硬件会根据中断号或异常号，将控制权转移到中断向量表或异常向量表中相应的位置。
* 中断向量表或异常向量表：中断向量表或异常向量表是一个数组，其中每个元素对应一个中断号或异常号。每个元素记录了处理该中断或异常的处理函数的地址。
* 选择处理函数：根据中断或异常的号码，在中断向量表或异常向量表中找到相应的处理函数的地址。
* 执行处理函数：将控制权转移到找到的处理函数的地址处，开始执行处理函数。
* 处理函数的执行：处理函数会根据具体的中断或异常类型，进行相应的处理。例如，对于时钟中断，处理函数会更新系统时间；对于缺页异常，处理函数会分配新的物理页面等。
* 中断或异常处理结束：当处理函数执行完毕后，控制权会返回到中断或异常发生的位置，系统会继续执行之前的指令。


2.其中mov a0，sp的目的是什么？
       mov a0, sp的目的是将当前的栈指针（Stack Pointer，SP）的值保存到寄存器a0中。这个操作的目的是为了在中断或异常处理函数中能够获取当前的栈指针的值，从而能够访问中断或异常发生时的上下文信息。中断或异常处理函数通常需要保存当前的上下文信息（例如程序计数器、寄存器等），然后执行相应的处理逻辑，最后恢复之前保存的上下文信息并返回。
       
3.SAVE_ALL中寄寄存器保存在栈中的位置是什么确定的？

SAVE_ALL是一个宏，用于保存中断或异常发生时CPU寄存器的值到栈中。保存寄存器的位置是由SAVE_ALL宏中的具体指令确定的。

4.对于任何中断，__alltraps 中都需要保存所有寄存器吗？

不是对于任何中断，__alltraps 都需要保存所有寄存器__alltraps 是ucore中的一个函数，用于处理中断和异常。在该函数中，保存寄存器的操作是由 SAVE_ALL 宏完成的，它会将通用寄存器、特殊寄存器和其他特定寄存器的值保存到栈中。

然而，对于某些中断或异常，可能只需要保存部分寄存器，而不是所有寄存器。这是因为不同的中断或异常可能只会影响特定的寄存器或需要保存的上下文信息不同。
## 扩增练习 Challenge2：理解上下文切换机制
>在trapentry.S中汇编代码 csrw sscratch, sp；csrrw s0, sscratch, x0实现了什么操作，目的是什么？save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？



1. csrw sscratch, sp：
这条指令将栈指针寄存器sp的值保存到sscratch特殊寄存器中。
目的是将当前栈指针保存到sscratch中，用于保存上下文。
2. csrrw s0, sscratch, x0：
这条指令将sscratch特殊寄存器的值读取到寄存器s0中，并将sscratch寄存器的值设置为零（通过写入x0）。
sscratch寄存器规定：若在中断之前处于U态(用户态)，保存的是内核栈地址；若在中断之前处于S态(内核态)，保存的是0。目的是如果出现递归异常，中断向量知道该异常来自内核态。
3. 当异常发生时，stval存储了导致异常的指令或数据的附加信息，在异常处理过程中，操作系统可以读取stval来获取异常原因。在异常处理完成后，不需要还原stval，因为它会在下一次异常发生时被硬件自动更新。同理scause存储了导致异常的原因，在异常处理完成后，不需要还原，会在下一次异常发生时被硬件自动更新。处理完中断后，也不需要这两个寄存器中保存的值，因此可以不恢复。

## Challenge3：完善异常中断

>编程完善在触发一条非法指令异常和断电异常时在 kern/trap/trap.c的异常处理函数中捕获，并对其进行处理，简单输出异常类型和异常指令触发地址，即“Illegal instruction caught at 0x(地址)”，“ebreak caught at 0x（地址）”与“Exception type:Illegal instruction"，“Exception type: breakpoint”。

- 实现代码如下：
~~~
case CAUSE_ILLEGAL_INSTRUCTION:
    // 非法指令异常处理
    /*(1)输出指令异常类型（ Illegal instruction）
     *(2)输出异常指令地址
     *(3)更新 tf->epc寄存器
    */
    cprintf("Exception type: Illegal instruction\n");
    cprintf("Illegal instruction caught at %p\n",tf->epc);
    tf->epc+=4;//假设异常指令占4个字节
    break;
case CAUSE_BREAKPOINT:
    //断点异常处理
    /*(1)输出指令异常类型（ breakpoint）
     *(2)输出异常指令地址
     *(3)更新 tf->epc寄存器
    */
    cprintf("Exception type: breakpoint\n");
    cprintf("ebreak caught at %p\n",tf->epc);
    tf->epc+=4;//假设异常指令占4个字节
    break;
~~~

- 流程说明：
当中断发生时，trapeframe中的epc记录着异常指令的地址，简单输出信息后，更新epc寄存器的值即将epc的值加4，去执行下面的指令。

在/kern/init/init.c中的初始化函数kern_init()中加入内联汇编代码
~~~
__asm__ volatile("mret");
__asm__ volatile("ebreak");
~~~
人为加入中断触发指令，继续make qemu发现成功触发。
![l1-e2-2.png](https://s2.loli.net/2023/09/23/xtQyc8mDpsPefFG.png)

## 实验总结

- 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解。
riscv中断处理机制，对应进程的上下文处理机制。riscv中断处理是当程序出现突发情况时，不得不停下当前的工作来进行应对；而上下文处理就是将当前寄存器的状态保存到内存中，并在合适的时机恢复。riscv的中断处理是包含了上下文处理机制的，除此之外，它还有中断情况分类、响应等操作，功能更加全面。
- 列出你认为OS原理中很重要，但在实验中没有对应上的知识点。
并发和进程切换、管理、调度等。实验没有一个CPU下执行多个进程的例子，也没有真正做到进程的切换等操作，只是单纯对上下文进行了保存与恢复。